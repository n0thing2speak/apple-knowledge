<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup theme-color -->
<!-- start theme color meta headers -->
<meta name="theme-color" content="#151515">
<meta name="msapplication-navbutton-color" content="#151515">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- end theme color meta headers -->


<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->


<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Mach &amp; BSD | Hack Different - Apple Knowledge</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Mach &amp; BSD" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Hack Different is a community of research around the Apple platform." />
<meta property="og:description" content="Hack Different is a community of research around the Apple platform." />
<link rel="canonical" href="https://docs.hackdiffe.rent/docs/Mach_and_BSD.html" />
<meta property="og:url" content="https://docs.hackdiffe.rent/docs/Mach_and_BSD.html" />
<meta property="og:site_name" content="Hack Different - Apple Knowledge" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Mach &amp; BSD" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Hack Different is a community of research around the Apple platform.","headline":"Mach &amp; BSD","url":"https://docs.hackdiffe.rent/docs/Mach_and_BSD.html"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <header>
      <div class="container">
        <a id="a-title" href="/">
          <h1>Hack Different - Apple Knowledge</h1>
        </a>
        <h2>Hack Different is a community of research around the Apple platform.</h2>

        <section id="downloads">
          
          <a href="https://github.com/hack-different/apple-knowledge" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1 id="mach--bsd">Mach &amp; BSD</h1>

<p>The Mach microkernel and the BSD kernel are the two major components of XNU.
<br />
Mach implements the absolute core of the operating system, while the BSD layer is built on top of Mach, and implements higher level concepts.</p>

<p><em>Note: As I’m writing this, I’m realizing that this whole writeup on Mach/BSD will be huge, so expect this article to be divided into several sub-articles soon.</em></p>

<h2 id="table-of-contents">Table of contents</h2>
<ul>
  <li><a href="#mach">Mach</a>
    <ul>
      <li><a href="#intro">Introduction</a></li>
      <li><a href="#philosophy">Philosophy</a></li>
      <li><a href="#implementation">Implementation</a>
        <ul>
          <li><a href="#execution_primitives">Execution primitives</a>
            <ul>
              <li><a href="#threads">Threads</a></li>
              <li><a href="#tasks">Tasks</a></li>
            </ul>
          </li>
          <li><a href="#ipc_primitives">IPC primitives</a>
            <ul>
              <li><a href="#messages">Messages</a>
                <ul>
                  <li><a href="#messages_intro">Introduction</a></li>
                  <li><a href="#utilizing_messages">Utilizing messages</a></li>
                </ul>
              </li>
              <li><a href="#ports">Ports</a>
                <ul>
                  <li><a href="#ports_intro">Introduction</a></li>
                  <li><a href="#port_rights">Port rights</a></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#bsd">BSD</a></li>
  <li><a href="#resources">Resources</a></li>
</ul>

<h2 id="mach">Mach</h2>

<p><a name="intro"></a></p>
<h3 id="introduction">Introduction</h3>
<p>Mach is a microkernel, originally designed by CMU between the 80s and the 90s. Apple chose this microkernel as the base of their new operating system, and has substantially modified it from the original version.</p>

<p>Mach is the absolute foundation of XNU, it deals with every crucial aspect needed for the correct functioning of the operating system. Mach does not bother with higher level concepts such as file systems or device drivers, for example. These concepts are left for other components to implement.</p>

<p><a name="philosophy"></a></p>
<h3 id="philosophy">Philosophy</h3>
<p>As stated before, Mach does not concern itself with higher level concepts, implementing just the bare-bones of the operating system. Mach is specifically designed to allow an entire operating system to be built upon it, which is exactly what Apple has done.</p>

<p>The core idea behind Mach its minimalism. Being a microkernel, Mach implements only the fundamental abstractions (described more in detail later).</p>

<p>Another key point in the Mach philosophy is how the various subsystems communicate, i.e. via a message passing facility. Interaction between components is completely implemented via IPC (inter-process communication) in Mach. This means that objects cannot directly call/invoke themselves, rather a message is sent from one object to another, that message is queued until the receiver handles it.
This may seem unconventional, and it is. But, since Mach is a microkernel, all of the subsystems are separated from one another, thus message passing is needed for communication.</p>

<p>Summarizing, remember that Mach is just the pure foundation of XNU, and everything else is built upon it.</p>

<p><a name="implementation"></a></p>
<h3 id="implementation">Implementation</h3>

<p><a name="execution_primitives"></a></p>
<h4 id="execution-primitives">Execution primitives</h4>

<p><a name="threads"></a></p>
<h5 id="threads">Threads</h5>
<p>Mach is responsible for the basics abstractions of execution.
<br />
The most basic unit of execution is indeed a <em>thread</em>. A thread provides basics scheduling statistics and machine registers, used for execution. Remember that a thread has no links to resources (such as virtual memory), as these are implemented in <em>tasks</em>.
<br />
Also remember that exist a direct link between a Mach thread and a BSD thread.</p>

<p><a name="tasks"></a></p>
<h5 id="tasks">Tasks</h5>
<p>A <em>task</em> is basically a container object. It implements resources, such as virtual memory, and its only purpose it’s to contain threads, since a task has no life by its own.
<br />
It also exist a direct map between Mach tasks and BSD processes, as with threads.
<br />
The threads in a task are kept in a singly linked list.</p>

<p><a name="ipc_primitives"></a></p>
<h4 id="ipc-primitives">IPC primitives</h4>

<p><a name="messages"></a></p>
<h5 id="messages">Messages</h5>

<p><a name="messages_intro"></a></p>
<h6 id="introduction-1">Introduction</h6>
<p>Mach messages are simply data exchanged between two endpoints, called ports. Mach messages constitutes the basic building block for IPC communication.</p>

<p>A message has an header (<code class="language-plaintext highlighter-rouge">mach_msg_header_t</code>), a body (<code class="language-plaintext highlighter-rouge">mach_msg_body_t</code>), and optionally a trailer (<code class="language-plaintext highlighter-rouge">mach_msg_trailer_t</code>).</p>

<p>The <strong>header</strong> contains all informations needed for the message to be sent and correctly received, such as:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">msgh_size</code>: The message size.</li>
  <li><code class="language-plaintext highlighter-rouge">msgh_remote_port</code>: The destination Mach port.</li>
  <li><code class="language-plaintext highlighter-rouge">msgh_local_port</code>: The local Mach port.</li>
  <li><code class="language-plaintext highlighter-rouge">msgh_id</code>: An unique ID. Used specifically with MIG.</li>
  <li><code class="language-plaintext highlighter-rouge">msgh_bits</code>: Optional bits.</li>
</ul>

<p>The standard <strong>body</strong> contains simply a <code class="language-plaintext highlighter-rouge">mach_msg_size_t</code>. The body is the actual data of the message and can contain virtually anything.</p>

<p>The <strong>trailer</strong> contains a <code class="language-plaintext highlighter-rouge">mach_msg_trailer_type_t</code> (<code class="language-plaintext highlighter-rouge">unsigned int</code>), which specifies the trailer type, and a <code class="language-plaintext highlighter-rouge">mach_msg_trailer_size_t</code> for specifying the trailer size.</p>

<p><a name="utilizing_messages"></a></p>
<h6 id="utilizing-messages">Utilizing messages</h6>
<p>Any user-land process is able to create Mach messages and use them for communication.
<br />
Creating a simple message is straightforward. You are able to construct your message in any way you want, the only really needed piece is the <code class="language-plaintext highlighter-rouge">mach_msg_header_t</code>, which must <strong>always</strong> be located at the beginning of the message.</p>

<p>Let’s assume we are going to use the following structure for our message:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* sending */
typedef struct simple_mach_message_send {
    mach_msg_header_t header;
    uint32_t x;
} simple_mach_message_send_t;
</code></pre></div></div>
<p>This would be our message, at least for sending. The reason why we need two separate structures for sending and receiving is that the kernel implicitly adds a small trailer to our message while sending it, therefore the received message will be larger than the original, and would fail to receive.
<br />
So, our structure for receiving:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* receiving */
typedef struct simple_mach_message_recv {
    mach_msg_header_t header;
    uint32_t x;
    mach_msg_trailer_t trailer; // we could also use something like `uint32_t pad[8];`
} simple_mach_message_recv_t;
</code></pre></div></div>
<p>This new structure is large enough and will contain the kernel-delivered message. Remember that your <code class="language-plaintext highlighter-rouge">send</code> struct instance’s data will be sent to the receiver, while the <code class="language-plaintext highlighter-rouge">recv</code> struct instance will be created by the receiver and will receive the <code class="language-plaintext highlighter-rouge">send</code> structure data (imagine locally copying a structure’s data to another structure).</p>

<p>The message’s header must be configured properly in order for the message to be sent/received. The absolutely necessary fields to set, for sending, are:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">msgh_bits</code>: Apart from indicating if the message is complex, this field specifies important message attributes, for example how to interpret the <code class="language-plaintext highlighter-rouge">msgh_remote_port</code> field and the <code class="language-plaintext highlighter-rouge">msgh_local_port</code> field. This can easily be filled with the use of the <code class="language-plaintext highlighter-rouge">MACH_MSGH_BITS(remote, local)</code> macro, where <code class="language-plaintext highlighter-rouge">remote</code> and <code class="language-plaintext highlighter-rouge">local</code> specify the interpretation of the two ports.</li>
  <li><code class="language-plaintext highlighter-rouge">msgh_remote_port</code>: Specifies the remote Mach port, i.e. where to send our message.</li>
  <li><code class="language-plaintext highlighter-rouge">msgh_size</code>: Specifies the message size. A <code class="language-plaintext highlighter-rouge">sizeof()</code> on your message structure will suffice.</li>
</ul>

<p>Additionally, you could specify other fields, such as <code class="language-plaintext highlighter-rouge">msgh_local_port</code> (a local Mach port, on which you hold receive rights) which could be interpreted by the receiver to send a reply message back.</p>

<p>Receiving requires only one necessary field to be set:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">msgh_size</code>: The message size expected to be received.</li>
</ul>

<p>The (more common) API used to send/receive message is <code class="language-plaintext highlighter-rouge">mach_msg</code>. This API indeed gives you the ability to both send/receive messages, by passing specific parameters. Here’s the definition:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern mach_msg_return_t	mach_msg(
					mach_msg_header_t *msg,
					mach_msg_option_t option,
					mach_msg_size_t send_size,
					mach_msg_size_t rcv_size,
					mach_port_name_t rcv_name,
					mach_msg_timeout_t timeout,
					mach_port_name_t notify);
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">mach_msg_header_t *msg</code>: Is the <code class="language-plaintext highlighter-rouge">mach_msg_header_t</code> of your structure instance (wether you are sending or receiving).</li>
  <li><code class="language-plaintext highlighter-rouge">mach_msg_option_t option</code>: The operation to perform. Send (<code class="language-plaintext highlighter-rouge">MACH_SEND_MSG</code>) or receive (<code class="language-plaintext highlighter-rouge">MACH_RCV_MSG</code>) are the most common.</li>
  <li><code class="language-plaintext highlighter-rouge">mach_msg_size_t send_size</code>: The size of the message you are sending. If you are receiving, pass <code class="language-plaintext highlighter-rouge">0</code> to this parameter.</li>
  <li><code class="language-plaintext highlighter-rouge">mach_msg_size_t rcv_size</code>: The size of the message you are receiving. If you are sending, this is optionally used to specify the size of the reply message. If you don’t want it, pass <code class="language-plaintext highlighter-rouge">0</code> to this parameter.</li>
  <li><code class="language-plaintext highlighter-rouge">mach_port_name_t rcv_name</code>: The Mach port for receiving the message. If you are sending, this is used to specify an optional reply port. If you don’t want it, pass <code class="language-plaintext highlighter-rouge">MACH_PORT_NULL</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">mach_msg_timeout_t timeout</code>: Optionally specifies a timeout before giving up on sending/receiving. Pass <code class="language-plaintext highlighter-rouge">MACH_MSG_TIMEOUT_NONE</code> is you don’t want a timeout.</li>
  <li><code class="language-plaintext highlighter-rouge">mach_port_name_t notify</code>: Optionally specifies a notification port, if you don’t want it, pass <code class="language-plaintext highlighter-rouge">MACH_PORT_NULL</code>.</li>
</ul>

<p>For more example and code, see the <code class="language-plaintext highlighter-rouge">/wiki/code/ipc/</code> folder, I have made a sample client/server which interact by sending/receiving a message.</p>

<p>Let’s now discuss <strong>complex messages</strong>. A message is deemed <em>complex</em> if the <code class="language-plaintext highlighter-rouge">MACH_MSGH_BITS_COMPLEX</code> flag is present in the <code class="language-plaintext highlighter-rouge">msgh_bits</code> field in its header. A complex message is structured differently: After the header, it follows a descriptor count field, followed by actual descriptors.
<br />
There are various types of descriptors, they generally serve the purpose of including special “attachments” to the message. Indeed, descriptors are specifically intended to “give hints” about what kind of out-of-line data we include in the message. Out-of-line data is simply data not directly included within the message itself, but instead allocated and kept somewhere else in memory, and only referenced (via a pointer, for example) by the message.</p>

<p>Here are the various descriptors defined in XNU:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MACH_MSG_PORT_DESCRIPTOR</code>: Used to specify passing a port right along with the message.</li>
  <li><code class="language-plaintext highlighter-rouge">MACH_MSG_OOL_DESCRIPTOR</code>: Used to specify passing generic out-of-line data.</li>
  <li><code class="language-plaintext highlighter-rouge">MACH_MSG_OOL_PORTS_DESCRIPTOR</code>: Used to specify passing a port.</li>
  <li><code class="language-plaintext highlighter-rouge">MACH_MSG_OOL_VOLATILE_DESCRIPTOR</code>: Used to specify passing generic volatile (subject to frequent change) out-of-line data.</li>
</ul>

<p>A sample structure for a complex message would be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct complex_message {
    mach_msg_header_t header;
    mach_msg_body_t body;
    mach_msg_ool_descriptor_t desc;
    mach_msg_trailer_t trailer;     /* optional, really */
};
</code></pre></div></div>

<p>In this case, the <code class="language-plaintext highlighter-rouge">mach_msg_body_t</code> is required since it specifies the descriptor count. You should set the latter to the actual number of descriptors you intend to include in your message. In our case, the <code class="language-plaintext highlighter-rouge">body.msgh_descriptor_count</code> would be <code class="language-plaintext highlighter-rouge">1</code>.</p>

<p>Now let’s take a look to the specific fields of the <code class="language-plaintext highlighter-rouge">mach_msg_ool_descriptor_t</code>. I have chosen to use the <code class="language-plaintext highlighter-rouge">mach_msg_ool_descriptor_t</code> since it represents generic data, is the most used, and is a fundamental part of a known heap defragmentation technique (heap feng shui), used to increase the chances of a successful exploit.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">address</code>: The OOL data address.</li>
  <li><code class="language-plaintext highlighter-rouge">deallocate</code>: Should the data be deallocated after send?</li>
  <li><code class="language-plaintext highlighter-rouge">copy</code>: Copy options.</li>
  <li><code class="language-plaintext highlighter-rouge">type</code>: Descriptor type.</li>
  <li><code class="language-plaintext highlighter-rouge">size</code>: Data size.</li>
</ul>

<p><a name="ports"></a></p>
<h5 id="ports">Ports</h5>

<p><a name="ports_intro"></a></p>
<h6 id="introduction-2">Introduction</h6>
<p>Mach ports are endpoints for communication. From user-land perspective, a Mach port is nothing more than an integer, an opaque handle to a more complex object held in-kernel.</p>

<p>Ports implement message queues to receive and enqueue messages. A message remains in a queue until a receiver dequeues it. Messages sent are guaranteed to be delivered.</p>

<p><a name="port_rights"></a></p>
<h6 id="port-rights">Port rights</h6>
<p>Ports may be accessed only via port rights. Those are basically permissions held by threads and tasks, needed to interact with ports. Here’s a list of all the port rights:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MACH_PORT_RIGHT_SEND</code>: Whoever holds this right for a specific port, is allowed to send (enqueue) messages to that port. More than one entity at a time are allowed to retain this right.</li>
  <li><code class="language-plaintext highlighter-rouge">MACH_PORT_RIGHT_RECEIVE</code>: Whoever holds this right for a specific port, is allowed to receive (dequeue) messages from that port. Holding this right corresponds to having ownership over the port. Only one entity at a time is allowed to retain this right.</li>
  <li><code class="language-plaintext highlighter-rouge">MACH_PORT_RIGHT_SEND_ONCE</code>: Akin to <code class="language-plaintext highlighter-rouge">MACH_PORT_RIGHT_SEND</code>, but the right is revoked after one message has been sent.</li>
  <li><code class="language-plaintext highlighter-rouge">MACH_PORT_RIGHT_PORT_SET</code>: Receive rights for multiple ports (a port set).</li>
</ul>

<p><a name="bsd"></a></p>
<h2 id="bsd">BSD</h2>
<p>BSD is primarily needed to implement what Mach leaves unimplemented. Things such as users, groups, files and others are obviously needed. BSD has also been heavily modified by Apple and differs significantly from other BSD implementations.</p>

<p>Although Mach builds the foundations, XNU can still be considered mostly a BSD-like system, since the POSIX APIs exposed are more complete and effectively more used than Mach’s.</p>

<p><a name="resources"></a></p>
<h3 id="resources">Resources</h3>
<p>A list of useful external resources.</p>

<ul>
  <li><a href="https://vimeo.com/127859750">A deep-dive into the many flavors of IPC available on OS X</a> : A talk by Ian Beer about IPC on OS X.</li>
</ul>

      </section>
    </div>
  </body>
</html>
