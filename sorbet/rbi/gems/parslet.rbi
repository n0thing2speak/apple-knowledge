# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/parslet/all/parslet.rbi
#
# parslet-2.0.0

class Parslet::Slice
  def +(other); end
  def ==(other); end
  def initialize(position, string, line_cache = nil); end
  def inspect; end
  def length; end
  def line_and_column; end
  def line_cache; end
  def match(regexp); end
  def offset; end
  def position; end
  def size; end
  def str; end
  def to_f; end
  def to_i; end
  def to_s; end
  def to_slice; end
  def to_str; end
  def to_sym; end
end
module Parslet
  def any; end
  def dynamic(&block); end
  def exp(str); end
  def infix_expression(element, *operations, &reducer); end
  def match(str = nil); end
  def scope(&block); end
  def self.any; end
  def self.dynamic(&block); end
  def self.exp(str); end
  def self.included(base); end
  def self.infix_expression(element, *operations, &reducer); end
  def self.match(str = nil); end
  def self.scope(&block); end
  def self.sequence(symbol); end
  def self.simple(symbol); end
  def self.str(str); end
  def self.subtree(symbol); end
  def sequence(symbol); end
  def simple(symbol); end
  def str(str); end
  def subtree(symbol); end
end
class Parslet::Cause
  def append_prefix(stream, curved); end
  def ascii_tree; end
  def children; end
  def initialize(message, source, pos, children); end
  def message; end
  def pos; end
  def raise(exception_klass = nil); end
  def recursive_ascii_tree(node, stream, curved); end
  def self.format(source, pos, str, children = nil); end
  def set_label(l); end
  def source; end
  def to_s; end
end
class Parslet::Position
  def <=>(b); end
  def bytepos; end
  def charpos; end
  def initialize(string, bytepos); end
  include Comparable
end
class Parslet::Source
  def bytepos; end
  def bytepos=(n); end
  def chars_left; end
  def chars_until(str); end
  def consume(n); end
  def initialize(str); end
  def line_and_column(position = nil); end
  def match(pattern); end
  def matches?(pattern); end
  def pos; end
end
class Parslet::Source::LineCache
  def initialize; end
  def line_and_column(pos); end
  def scan_for_line_endings(start_pos, buf); end
end
module Parslet::Source::RangeSearch
  def find_mid(left, right); end
  def lbound(bound); end
end
module Parslet::Atoms
end
module Parslet::Atoms::CanFlatten
  def flatten(value, named = nil); end
  def flatten_repetition(list, named); end
  def flatten_sequence(list); end
  def foldl(list, &block); end
  def merge_fold(l, r); end
  def warn_about_duplicate_keys(h1, h2); end
end
class Parslet::Atoms::Context
  def captures; end
  def err(*args); end
  def err_at(*args); end
  def initialize(reporter = nil); end
  def lookup(obj, pos); end
  def scope; end
  def set(obj, pos, val); end
  def succ(*args); end
  def try_with_cache(obj, source, consume_all); end
end
module Parslet::Atoms::DSL
  def >>(parslet); end
  def absent?; end
  def as(name); end
  def capture(name); end
  def ignore; end
  def maybe; end
  def present?; end
  def repeat(min = nil, max = nil); end
  def |(parslet); end
end
class Parslet::Atoms::Base
  def apply(source, context, consume_all = nil); end
  def cached?; end
  def inspect; end
  def label; end
  def label=(arg0); end
  def parse(io, options = nil); end
  def precedence; end
  def self.precedence(prec); end
  def setup_and_apply(source, error_reporter, consume_all); end
  def succ(result); end
  def to_s(outer_prec = nil); end
  def try(source, context, consume_all); end
  include Parslet::Atoms::CanFlatten
  include Parslet::Atoms::DSL
  include Parslet::Atoms::Precedence
end
class Parslet::Atoms::Ignored < Parslet::Atoms::Base
  def apply(source, context, consume_all); end
  def initialize(parslet); end
  def parslet; end
  def to_s_inner(prec); end
end
class Parslet::Atoms::Named < Parslet::Atoms::Base
  def apply(source, context, consume_all); end
  def initialize(parslet, name); end
  def name; end
  def parslet; end
  def produce_return_value(val); end
  def to_s_inner(prec); end
end
class Parslet::Atoms::Lookahead < Parslet::Atoms::Base
  def bound_parslet; end
  def error_msgs; end
  def initialize(bound_parslet, positive = nil); end
  def positive; end
  def precedence; end
  def to_s_inner(prec); end
  def try(source, context, consume_all); end
end
class Parslet::Atoms::Alternative < Parslet::Atoms::Base
  def alternatives; end
  def error_msg; end
  def initialize(*alternatives); end
  def precedence; end
  def to_s_inner(prec); end
  def try(source, context, consume_all); end
  def |(parslet); end
end
class Parslet::Atoms::Sequence < Parslet::Atoms::Base
  def >>(parslet); end
  def error_msgs; end
  def initialize(*parslets); end
  def parslets; end
  def precedence; end
  def to_s_inner(prec); end
  def try(source, context, consume_all); end
end
class Parslet::Atoms::Repetition < Parslet::Atoms::Base
  def error_msgs; end
  def initialize(parslet, min, max, tag = nil); end
  def max; end
  def min; end
  def parslet; end
  def precedence; end
  def to_s_inner(prec); end
  def try(source, context, consume_all); end
end
class Parslet::Atoms::Re < Parslet::Atoms::Base
  def error_msgs; end
  def initialize(match); end
  def match; end
  def re; end
  def to_s_inner(prec); end
  def try(source, context, consume_all); end
end
class Parslet::Atoms::Str < Parslet::Atoms::Base
  def error_msgs; end
  def initialize(str); end
  def str; end
  def to_s_inner(prec); end
  def try(source, context, consume_all); end
end
class Parslet::Atoms::Entity < Parslet::Atoms::Base
  def block; end
  def initialize(name, label = nil, &block); end
  def name; end
  def parslet; end
  def raise_not_implemented; end
  def to_s_inner(prec); end
  def try(source, context, consume_all); end
end
class Parslet::Atoms::Capture < Parslet::Atoms::Base
  def apply(source, context, consume_all); end
  def initialize(parslet, name); end
  def name; end
  def parslet; end
  def to_s_inner(prec); end
end
class Parslet::Atoms::Dynamic < Parslet::Atoms::Base
  def block; end
  def cached?; end
  def initialize(block); end
  def to_s_inner(prec); end
  def try(source, context, consume_all); end
end
class Parslet::Atoms::Scope < Parslet::Atoms::Base
  def apply(source, context, consume_all); end
  def block; end
  def cached?; end
  def initialize(block); end
  def to_s_inner(prec); end
end
class Parslet::Atoms::Infix < Parslet::Atoms::Base
  def element; end
  def initialize(element, operations, &reducer); end
  def match_operation(source, context, consume_all); end
  def operations; end
  def precedence_climb(source, context, consume_all, current_prec = nil, needs_element = nil); end
  def produce_tree(ary); end
  def reducer; end
  def to_s_inner(prec); end
  def try(source, context, consume_all); end
  def unwrap(expr); end
end
module Parslet::Atoms::Precedence
end
class Parslet::Pattern
  def element_match(tree, exp, bindings); end
  def element_match_ary_single(sequence, exp, bindings); end
  def element_match_binding(tree, exp, bindings); end
  def element_match_hash(tree, exp, bindings); end
  def initialize(pattern); end
  def match(subtree, bindings = nil); end
end
class Anonymous_Struct_17 < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def symbol; end
  def symbol=(_); end
end
class Parslet::Pattern::SubtreeBind < Anonymous_Struct_17
  def bind_type_name; end
  def can_bind?(subtree); end
  def inspect; end
  def variable_name; end
end
class Parslet::Pattern::SimpleBind < Parslet::Pattern::SubtreeBind
  def can_bind?(subtree); end
end
class Parslet::Pattern::SequenceBind < Parslet::Pattern::SubtreeBind
  def can_bind?(subtree); end
end
class Parslet::Context
  def initialize(bindings); end
  extend Parslet::ClassMethods
  include Parslet
end
class Parslet::Transform
  def apply(obj, context = nil); end
  def call_on_match(bindings, block); end
  def initialize(raise_on_unmatch = nil, &block); end
  def recurse_array(ary, ctx); end
  def recurse_hash(hsh, ctx); end
  def rule(expression, &block); end
  def rules; end
  def self.inherited(subclass); end
  def self.rule(expression, &block); end
  def self.rules; end
  def transform_elt(elt, context); end
  extend Parslet::ClassMethods
  include Parslet
end
class Parslet::Parser < Parslet::Atoms::Base
  def self.root(name); end
  def to_s_inner(prec); end
  def try(source, context, consume_all); end
  extend Parslet::ClassMethods
  include Parslet
end
module Parslet::ErrorReporter
end
class Parslet::ErrorReporter::Tree
  def err(atom, source, message, children = nil); end
  def err_at(atom, source, message, pos, children = nil); end
  def succ(source); end
end
class Parslet::ErrorReporter::Deepest
  def deepest(cause); end
  def deepest_cause; end
  def deepest_child(cause, rank = nil); end
  def err(atom, source, message, children = nil); end
  def err_at(atom, source, message, pos, children = nil); end
  def initialize; end
  def succ(source); end
end
class Parslet::ErrorReporter::Contextual < Parslet::ErrorReporter::Deepest
  def err(atom, source, message, children = nil); end
  def initialize; end
  def reset; end
  def succ(source); end
  def update_label(label, bytepos); end
end
class Parslet::Scope
  def [](k); end
  def []=(k, v); end
  def initialize; end
  def pop; end
  def push; end
end
class Parslet::Scope::NotFound < StandardError
end
class Parslet::Scope::Binding
  def [](k); end
  def []=(k, v); end
  def initialize(parent = nil); end
  def parent; end
end
class Parslet::ParseFailed < StandardError
  def initialize(message, parse_failure_cause = nil); end
  def parse_failure_cause; end
end
module Parslet::ClassMethods
  def rule(name, opts = nil, &definition); end
end
class Parslet::DelayedMatchConstructor
  def [](str); end
end
