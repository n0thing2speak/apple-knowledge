# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: ignore
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/activesupport/all/activesupport.rbi
#
# activesupport-7.0.2.3

class Module
  def as_json(options = nil); end
  def cattr_accessor(*syms, instance_reader: nil, instance_writer: nil, instance_accessor: nil, default: nil, &blk); end
  def cattr_reader(*syms, instance_reader: nil, instance_accessor: nil, default: nil, location: nil); end
  def cattr_writer(*syms, instance_writer: nil, instance_accessor: nil, default: nil, location: nil); end
  def delegate(*methods, to: nil, prefix: nil, allow_nil: nil, private: nil); end
  def delegate_missing_to(target, allow_nil: nil); end
  def mattr_accessor(*syms, instance_reader: nil, instance_writer: nil, instance_accessor: nil, default: nil, &blk); end
  def mattr_reader(*syms, instance_reader: nil, instance_accessor: nil, default: nil, location: nil); end
  def mattr_writer(*syms, instance_writer: nil, instance_accessor: nil, default: nil, location: nil); end
  def method_visibility(method); end
  def redefine_method(method, &block); end
  def redefine_singleton_method(method, &block); end
  def silence_redefinition_of_method(method); end
end
class Module::DelegationError < NoMethodError
end
module ActiveSupport
  def parse_json_times; end
  def parse_json_times=(val); end
  def self.escape_html_entities_in_json(**, ****, &&); end
  def self.escape_html_entities_in_json=(arg); end
  def self.json_encoder(**, ****, &&); end
  def self.json_encoder=(arg); end
  def self.parse_json_times; end
  def self.parse_json_times=(val); end
  def self.time_precision(**, ****, &&); end
  def self.time_precision=(arg); end
  def self.use_standard_json_time_format(**, ****, &&); end
  def self.use_standard_json_time_format=(arg); end
  extend ActiveSupport::LazyLoadHooks
end
module ActiveSupport::JSON
  def self.convert_dates_from(data); end
  def self.decode(json); end
  def self.encode(value, options = nil); end
  def self.parse_error; end
end
module ActiveSupport::BigDecimalWithDefaultFormat
  def to_s(format = nil); end
end
class Hash
  def as_json(options = nil); end
  def blank?; end
  def deep_merge!(other_hash, &block); end
  def deep_merge(other_hash, &block); end
  def except!(*keys); end
  def extract!(*keys); end
  def slice!(*keys); end
end
class Object < BasicObject
  def as_json(options = nil); end
  def blank?; end
  def instance_values; end
  def instance_variable_names; end
  def presence; end
  def present?; end
end
module ActiveSupport::LazyLoadHooks
  def execute_hook(name, base, options, block); end
  def on_load(name, options = nil, &block); end
  def run_load_hooks(name, base = nil); end
  def self.extended(base); end
  def with_execution_control(name, block, once); end
end
module ActiveSupport::Inflector
  def apply_inflections(word, rules, locale = nil); end
  def camelize(term, uppercase_first_letter = nil); end
  def classify(table_name); end
  def const_regexp(camel_cased_word); end
  def constantize(camel_cased_word); end
  def dasherize(underscored_word); end
  def deconstantize(path); end
  def demodulize(path); end
  def foreign_key(class_name, separate_class_name_and_id_with_underscore = nil); end
  def humanize(lower_case_and_underscored_word, capitalize: nil, keep_id_suffix: nil); end
  def inflections(locale = nil); end
  def ordinal(number); end
  def ordinalize(number); end
  def parameterize(string, separator: nil, preserve_case: nil, locale: nil); end
  def pluralize(word, locale = nil); end
  def safe_constantize(camel_cased_word); end
  def singularize(word, locale = nil); end
  def tableize(class_name); end
  def titleize(word, keep_id_suffix: nil); end
  def transliterate(string, replacement = nil, locale: nil); end
  def underscore(camel_cased_word); end
  def upcase_first(string); end
  extend ActiveSupport::Inflector
  extend ActiveSupport::Inflector
end
class ActiveSupport::Inflector::Inflections
  def acronym(word); end
  def acronyms; end
  def acronyms_camelize_regex; end
  def acronyms_underscore_regex; end
  def clear(scope = nil); end
  def define_acronym_regex_patterns; end
  def human(rule, replacement); end
  def humans; end
  def initialize; end
  def initialize_dup(orig); end
  def irregular(singular, plural); end
  def plural(rule, replacement); end
  def plurals; end
  def self.instance(locale = nil); end
  def self.instance_or_fallback(locale); end
  def singular(rule, replacement); end
  def singulars; end
  def uncountable(*words); end
  def uncountables; end
end
class ActiveSupport::Inflector::Inflections::Uncountables < Array
  def <<(*word); end
  def add(words); end
  def delete(entry); end
  def initialize; end
  def to_regex(string); end
  def uncountable?(str); end
end
class NilClass
  def as_json(options = nil); end
  def blank?; end
end
class FalseClass
  def as_json(options = nil); end
  def blank?; end
end
class TrueClass
  def as_json(options = nil); end
  def blank?; end
end
class Array
  def as_json(options = nil); end
  def blank?; end
  def excluding(*elements); end
  def fifth; end
  def forty_two; end
  def fourth; end
  def from(position); end
  def including(*elements); end
  def second; end
  def second_to_last; end
  def self.try_convert(arg0); end
  def third; end
  def third_to_last; end
  def to(position); end
  def without(*elements); end
end
class String
  def as_json(options = nil); end
  def blank?; end
  def camelcase(first_letter = nil); end
  def camelize(first_letter = nil); end
  def classify; end
  def constantize; end
  def dasherize; end
  def deconstantize; end
  def demodulize; end
  def foreign_key(separate_class_name_and_id_with_underscore = nil); end
  def humanize(capitalize: nil, keep_id_suffix: nil); end
  def is_utf8?; end
  def mb_chars; end
  def parameterize(separator: nil, preserve_case: nil, locale: nil); end
  def pluralize(count = nil, locale = nil); end
  def safe_constantize; end
  def singularize(locale = nil); end
  def tableize; end
  def titlecase(keep_id_suffix: nil); end
  def titleize(keep_id_suffix: nil); end
  def underscore; end
  def upcase_first; end
end
class Numeric
  def as_json(options = nil); end
  def blank?; end
end
class Time
  def as_json(options = nil); end
  def blank?; end
  def formatted_offset(colon = nil, alternate_utc_string = nil); end
  def rfc3339(fraction_digits = nil); end
  def to_default_s; end
  def to_formatted_s(format = nil); end
  def to_fs(format = nil); end
end
class ActiveSupport::TimeZone
  def <=>(zone); end
  def =~(re); end
  def at(*args); end
  def encode_with(coder); end
  def formatted_offset(colon = nil, alternate_utc_string = nil); end
  def init_with(coder); end
  def initialize(name, utc_offset = nil, tzinfo = nil); end
  def iso8601(str); end
  def local(*args); end
  def local_to_utc(time, dst = nil); end
  def match?(re); end
  def name; end
  def now; end
  def parse(str, now = nil); end
  def parts_to_time(parts, now); end
  def period_for_local(time, dst = nil); end
  def period_for_utc(time); end
  def periods_for_local(time); end
  def rfc3339(str); end
  def self.[](arg); end
  def self.all; end
  def self.clear; end
  def self.country_zones(country_code); end
  def self.create(*arg0, ****); end
  def self.find_tzinfo(name); end
  def self.load_country_zones(code); end
  def self.new(name); end
  def self.seconds_to_utc_offset(seconds, colon = nil); end
  def self.us_zones; end
  def self.zones_map; end
  def strptime(str, format, now = nil); end
  def time_now; end
  def to_s; end
  def today; end
  def tomorrow; end
  def tzinfo; end
  def utc_offset; end
  def utc_to_local(time); end
  def yesterday; end
  include Comparable
end
class DateTime < Date
  def <=>(other); end
  def advance(options); end
  def ago(seconds); end
  def as_json(options = nil); end
  def at_beginning_of_day; end
  def at_beginning_of_hour; end
  def at_beginning_of_minute; end
  def at_end_of_day; end
  def at_end_of_hour; end
  def at_end_of_minute; end
  def at_midday; end
  def at_middle_of_day; end
  def at_midnight; end
  def at_noon; end
  def beginning_of_day; end
  def beginning_of_hour; end
  def beginning_of_minute; end
  def change(options); end
  def default_inspect; end
  def end_of_day; end
  def end_of_hour; end
  def end_of_minute; end
  def formatted_offset(colon = nil, alternate_utc_string = nil); end
  def getgm; end
  def getlocal(utc_offset = nil); end
  def getutc; end
  def gmtime; end
  def in(seconds); end
  def inspect; end
  def localtime(utc_offset = nil); end
  def midday; end
  def middle_of_day; end
  def midnight; end
  def noon; end
  def nsec; end
  def offset_in_seconds; end
  def readable_inspect; end
  def seconds_since_midnight; end
  def seconds_since_unix_epoch; end
  def seconds_until_end_of_day; end
  def self.civil_from_format(utc_or_local, year, month = nil, day = nil, hour = nil, min = nil, sec = nil); end
  def self.current; end
  def since(seconds); end
  def subsec; end
  def to_default_s; end
  def to_f; end
  def to_formatted_s(format = nil); end
  def to_fs(format = nil); end
  def to_i; end
  def usec; end
  def utc; end
  def utc?; end
  def utc_offset; end
end
module DateAndTime
end
module DateAndTime::Zones
  def in_time_zone(zone = nil); end
  def time_with_zone(time, zone); end
end
class Date
  def as_json(options = nil); end
  def default_inspect; end
  def readable_inspect; end
  def to_default_s; end
  def to_formatted_s(format = nil); end
  def to_fs(format = nil); end
  include DateAndTime::Zones
end
module ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_json(options = nil); end
end
class Struct
  def as_json(options = nil); end
end
class Symbol
  def as_json(options = nil); end
end
class Float < Numeric
  def as_json(options = nil); end
end
class BigDecimal < Numeric
  def as_json(options = nil); end
end
class Regexp
  def as_json(options = nil); end
end
module Enumerable
  def as_json(options = nil); end
end
class IO
  def as_json(options = nil); end
end
class Range
  def as_json(options = nil); end
end
class URI::Generic
  def as_json(options = nil); end
end
class Pathname
  def as_json(options = nil); end
end
class IPAddr
  def as_json(options = nil); end
end
class Process::Status
  def as_json(options = nil); end
end
class Exception
  def as_json(options = nil); end
end
module ActiveSupport::JSON::Encoding
  def self.escape_html_entities_in_json; end
  def self.escape_html_entities_in_json=(arg0); end
  def self.json_encoder; end
  def self.json_encoder=(arg0); end
  def self.time_precision; end
  def self.time_precision=(arg0); end
  def self.use_standard_json_time_format; end
  def self.use_standard_json_time_format=(arg0); end
end
class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end
  def initialize(options = nil); end
  def jsonify(value); end
  def options; end
  def stringify(jsonified); end
end
class ActiveSupport::JSON::Encoding::JSONGemEncoder::EscapedString < String
  def to_json(*arg0); end
  def to_s; end
end
module ActiveSupport::XmlMini_Nokogiri
  def parse(data); end
  extend ActiveSupport::XmlMini_Nokogiri
end
module ActiveSupport::XmlMini_Nokogiri::Conversions
end
module ActiveSupport::XmlMini_Nokogiri::Conversions::Document
  def to_hash; end
end
module ActiveSupport::XmlMini_Nokogiri::Conversions::Node
  def to_hash(hash = nil); end
end
class Nokogiri::XML::Document < Nokogiri::XML::Node
  include ActiveSupport::XmlMini_Nokogiri::Conversions::Document
end
class Nokogiri::XML::Node
  include ActiveSupport::XmlMini_Nokogiri::Conversions::Node
end
module ActiveSupport::Multibyte
  def self.proxy_class; end
  def self.proxy_class=(klass); end
end
module Kernel
  def enable_warnings(&block); end
  def self.enable_warnings(&block); end
  def self.silence_warnings(&block); end
  def self.suppress(*exception_classes); end
  def self.with_warnings(flag); end
  def silence_warnings(&block); end
  def suppress(*exception_classes); end
  def with_warnings(flag); end
end
module ActiveSupport::XmlMini_REXML
  def collapse(element, depth); end
  def empty_content?(element); end
  def get_attributes(element); end
  def merge!(hash, key, value); end
  def merge_element!(hash, element, depth); end
  def merge_texts!(hash, element); end
  def parse(data); end
  def require_rexml; end
  extend ActiveSupport::XmlMini_REXML
end
module ActiveSupport::XmlMini
  def _dasherize(key); end
  def _parse_binary(bin, entity); end
  def _parse_file(file, entity); end
  def backend; end
  def backend=(name); end
  def cast_backend_name_to_module(name); end
  def current_thread_backend; end
  def current_thread_backend=(name); end
  def depth; end
  def depth=(arg0); end
  def parse(**, ****, &&); end
  def rename_key(key, options = nil); end
  def to_tag(key, value, options); end
  def with_backend(name); end
  extend ActiveSupport::XmlMini
  extend ActiveSupport::XmlMini
end
module ActiveSupport::XmlMini::FileLike
  def content_type; end
  def content_type=(arg0); end
  def original_filename; end
  def original_filename=(arg0); end
end
